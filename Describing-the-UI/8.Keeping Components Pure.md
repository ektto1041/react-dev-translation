# 구성 요소를 pure하게 유지
일부 JavaScript 함수는 순수(pure)합니다. 
pure 함수는 계산만 수행하며 그 이상은 수행하지 않습니다. 
구성 요소를 pure 함수로만 작성하면 코드 베이스가 커짐에 따라 당황스러운 버그와 예측할 수 없는 동작을 방지할 수 있습니다. 
하지만 이러한 이점을 얻으려면 따라야 할 몇 가지 규칙이 있습니다.

## 순도: 수학공식 특성의 구성요소
컴퓨터 과학(특히 함수형 프로그래밍의 세계)에서 순수 함수는 다음과 같은 특성을 가진 함수입니다.

* **자신의 업무역할만을 고려합니다**. 호출되기 전에 존재했던 기존의 객체나 변수는 변경되지 않습니다.
* **동일한 입력, 동일한 출력**. 동일한 입력이 주어지면 순수 함수는 항상 동일한 결과를 반환해야 합니다.

여러분은 이미 순수 함수의 한 가지 예인 수학 공식에 익숙할 것입니다.

다음 수학 공식을 생각해 보세요: y = 2x.
x = 2이면 y = 4입니다. x = 3이면 y = 6입니다. 항상 그렇습니다.

시간 흐름에 따라 또는 주식 시장 같은 상황에 따라서는, x = 3인 경우 y는  9, -1 또는 2.5가 되지 않을 수도 있습니다.
이것을 JavaScript 함수로 만들면 다음과 같습니다.

![image](https://github.com/ektto1041/react-dev-translation-study/assets/165557124/a286b38d-617a-430f-892e-78bf513aaad1)

위의 예에서 `double`은 순수 함수입니다. 3을 전달하면 6이 반환됩니다. 항상요.

React는 이 개념을 중심으로 설계되었습니다. 

**React는 여러분이 작성하는 모든 구성요소가 순수 함수라고 가정합니다.**

이는 작성하는 React 구성 요소가 **동일한 입력이 주어지면 항상 동일한 JSX를 반환해야 함을 의미**합니다.
![image](https://github.com/ektto1041/react-dev-translation-study/assets/165557124/40192e7a-1828-412e-bcdd-ddca8abc985d)


`drinkers={2}`를 `Recipe`에 전달하면 `2 cups of water`이 포함된 JSX가 반환됩니다. 언제나.

`drinkers={4}`를 전달하면 `4 cups of water`이 포함된 JSX가 반환됩니다. 언제나.

마치 수학 공식과 같습니다.

구성 요소를 레시피라고 생각할 수 있습니다. 
구성 요소를 따르고 요리 과정에서 새로운 재료를 넣지 않으면 매번 동일한 요리를 얻게 됩니다. 

해당 "dish"는 구성 요소가 `렌더링`을 위해 React에 제공되는 JSX입니다.

## side effects: (의도하지 않은) 결과
React의 렌더링 프로세스는 항상 순수해야 합니다. 
구성 요소는 `JSX만 반환`해야 하며, `렌더링 전에 존재했던 객체나 변수를 변경하면 안 됩니다`. 그러면 not pure해질 수 있습니다!

이 규칙을 깨는 구성 요소는 다음과 같습니다.
![image](https://github.com/ektto1041/react-dev-translation-study/assets/165557124/5328a289-514b-4dd3-9b81-d20ade60820e)

이 구성 요소는 외부에 선언된 `guest` 변수를 읽고 쓰고 있습니다. 
즉, **이 구성 요소를 여러 번 호출하면 다른 JSX가 생성됩니다!**

게다가 다른 구성 요소가 `guest`를 읽는 경우, 렌더링 시기에 따라 다른 JSX도 생성됩니다! 그건 예측할 수 없습니다.

공식 y = 2x로 돌아가면 이제 x = 2라도 y = 4라는 것을 믿을 수 없습니다.
테스트가 실패하고 사용자는 당황하며 비행기가 하늘에서 떨어질 것입니다. 

이것이 어떻게 혼란스러운 버그가 진행되는지 알 수 있습니다. 

**대신 `guest`를 prop으로 전달하여 이 구성 요소를 수정할 수 있습니다.**
![image](https://github.com/ektto1041/react-dev-translation-study/assets/165557124/cda7e1e9-7976-4fec-b6fd-c95849a4c490)

이제 반환되는 JSX는 `guest` prop에만 의존하므로 구성 요소는 순수합니다.

일반적으로 구성 요소가 특정 순서로 렌더링될 것이라고 기대해서는 안 됩니다. 

y = 5x 이전이나 이후에 y = 2x를 호출하는지는 중요하지 않습니다. 
두 수식은 서로 독립적으로 해결됩니다. 

마찬가지로 **각 구성 요소는 "스스로 생각"해야 하며 렌더링 중에 다른 구성 요소와 조정하거나 의존하려고 시도해서는 안 됩니다.**
렌더링은 학교 시험과 같습니다. 각 구성 요소는 자체적으로 JSX를 계산해야 합니다!

### StrictMode로 impure한 계산 감지
아직 모두 사용하지 않았을 수도 있지만 React에는 **렌더링하는 동안 읽을 수 있는 세 가지 종류의 입력(`props`, `state` 및 `context`)이 있습니다**. 
이러한 입력은 **항상 읽기 전용으로 처리**해야 합니다.

사용자 입력에 대한 응답으로 무언가를 변경하려면 **변수에 쓰는 대신 상태를 설정**해야 합니다. 
구성 요소가 렌더링되는 동안 기존 변수나 개체를 변경하면 안 됩니다.

React는 개발 중에 각 구성 요소의 기능을 두 번 호출하는 "Strict Mode"를 제공합니다. 
**`Strict Mode`는 구성 요소 함수를 두 번 호출하여, 이러한 규칙을 위반하는 구성 요소를 찾는 데 도움이 됩니다.**

원래 예에서는 "Guest #1", "Guest #2", "Guest #3" 대신 "Guest #2", "Guest #4", "Guest #6"이 표시되었습니다. 

원래 함수는 impure해서 두 번 호출하면 문제가 발생했습니다. 
하지만 고정된 순수 버전은 함수가 매번 두 번 호출되더라도 작동합니다. 

**순수 함수는 계산만 하기 때문에 두 번 호출해도 아무 것도 바뀌지 않습니다.**
마치 `double(2)`을 두 번 호출해도 반환된 내용이 바뀌지 않고, y = 2x를 두 번 풀어도 y가 바뀌지 않는 것과 같습니다. 동일한 입력, 동일한 출력. 항상요.

`Strict Mode`는 프로덕션(성능)에 영향을 주지 않으므로 사용자의 앱 속도가 느려지지 않습니다. 
`Strict 모드`를 선택하려면 **루트 구성 요소를 <React.StrictMode>로 래핑하면 됩니다**. 일부 프레임워크에서는 기본적으로 이 작업을 수행합니다.

## 컴포넌트의 지역 변이 (local mutation)
* 변이(mutation) - 렌더링하는 동안 기존 변수를 변경하는 동작
* 순수 함수는 외부 변수나 호출 전에 생성된 객체를 '변이'하지 않음

위의 예에서 문제는 구성 요소가 렌더링하는 동안 기존 변수를 변경했다는 것입니다. 
이것을 좀 더 무섭게 들리게 하기 위해 흔히 “변이”라고 부릅니다. 

순수 함수는 함수 범위 밖의 변수나 호출 전에 생성된 객체를 변경하지 않습니다. 즉, 순수하지 않습니다!

그러나 **렌더링하는 동안 방금 생성한 변수와 개체를 변경하는 것은 전혀 문제가 되지 않습니다.** 
이 예에서는 `[]` 배열을 만들고 이를 `cup` 변수에 할당한 다음 12개의 컵을 여기에 `push` 넣습니다.
![image](https://github.com/ektto1041/react-dev-translation-study/assets/165557124/f60e3327-8116-4808-90ed-eb066d358df3)

만약 `cup` 변수나 `[]` 배열이 `TeaGathering` 함수 외부에서 생성되었다면 이는 큰 문제가 될 것입니다! 
해당 `[]`배열에 items을 `push`하여 기존 객체를 변경하게 됩니다.

그러나 `TeaGathering` 내부에서 동일한 렌더링 중에 생성했기 때문에 괜찮습니다. 
`TeaGathering` 외부의 어떤 코드도 이런 일이 발생했다는 사실을 알 수 없습니다. 

이를 "**지역 변이**"라고 합니다. 이는 구성 요소의 작은 비밀과 같습니다.

## 어디서 side effects 를 발생시키는가
함수형 프로그래밍은 순수성에 크게 의존하지만, 어느 시점, 어딘가에서는 무언가 변경되어야 합니다. 

그것이 바로 프로그래밍의 핵심입니다! 
화면 업데이트, 애니메이션 시작, 데이터 변경 등 이러한 변경을 **side effects**이라고 합니다. 렌더링하는 동안이 아니라 렌더링 후에 "부수적으로" 발생하는 일입니다.

React에서 **side effects은 일반적으로 이벤트 핸들러 내부**에 속합니다. 
이벤트 핸들러는 버튼을 클릭하는 등의 작업을 수행할 때 React가 실행하는 함수입니다. 

이벤트 핸들러가 구성 요소 내부에 정의되어 있더라도 렌더링 중에는 실행되지 않습니다! **따라서 이벤트 핸들러는 순수할 필요가 없습니다.**

### React는 왜 순수성에 중시할까?
순수 함수를 작성하려면 약간의 습관과 규칙이 필요합니다. 하지만 이는 또한 놀라운 기회를 열어줍니다.

* 구성 요소는 다른 환경(서버 같은)에서 실행될 수 있습니다! 동일한 입력에 대해 동일한 결과를 반환하므로 하나의 컴포넌트가 많은 사용자 요청을 처리할 수 있습니다.
* 입력이 변경되지 않은 **렌더링 구성 요소를 건너뛰면(skip)** 성능을 향상시킬 수 있습니다. 순수 함수는 항상 동일한 결과를 반환하므로 이는 안전합니다. - **캐싱해도 안전** -
* **deep 컴포넌트 tree를 렌더링하는 도중 일부 데이터가 변경되면, React는 오래된 렌더링을 완료하는 데 시간을 낭비하지 않고 렌더링을 다시 시작할 수 있습니다.** `Purity`는 언제든지 계산을 중단해도 안전합니다.

우리가 구축하는 모든 새로운 React 기능은 순수성을 활용합니다. 데이터 가져오기부터 애니메이션, 성능까지 구성 요소를 순수하게 유지하면 React 패러다임의 힘이 발휘됩니다.

